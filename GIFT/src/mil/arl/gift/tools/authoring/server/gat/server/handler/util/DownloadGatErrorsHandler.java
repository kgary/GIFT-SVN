/**
 * Copyright Dignitas Technologies, LLC
 * 
 * This file and its contents are governed by one or more distribution and
 * copyright statements as described in the LICENSE.txt file distributed with
 * this work.
 */
package mil.arl.gift.tools.authoring.server.gat.server.handler.util;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;

import org.apache.commons.io.FileUtils;
import org.apache.commons.lang.time.FastDateFormat;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import mil.arl.gift.common.gwt.client.ErrorDetails;
import mil.arl.gift.common.metrics.MetricsSenderSingleton;
import mil.arl.gift.common.io.FileUtil;
import mil.arl.gift.common.io.TimeUtil;
import mil.arl.gift.common.io.ZipUtils;
import mil.arl.gift.domain.DomainModuleProperties;
import mil.arl.gift.tools.authoring.server.gat.shared.action.util.DownloadGatErrors;
import mil.arl.gift.tools.authoring.server.gat.shared.action.util.DownloadGatErrorsResult;
import mil.arl.gift.tools.services.ServicesManager;
import net.customware.gwt.dispatch.server.ActionHandler;
import net.customware.gwt.dispatch.server.ExecutionContext;
import net.customware.gwt.dispatch.shared.DispatchException;

/**
 * An action handler that writes error details to a file for download.
 * 
 * @author bzahid
 */
public class DownloadGatErrorsHandler implements ActionHandler<DownloadGatErrors, DownloadGatErrorsResult> {

	/**  instance of the logger. */
    private static Logger logger = LoggerFactory.getLogger(DownloadGatErrorsHandler.class);
    
    /** Date formatter used for the error timestamp. 
     * NOTE: null Locale and Timezone arguments make the formatter use the system defaults. */
    private static final FastDateFormat fdf =  FastDateFormat.getInstance("MM-dd-yyyy HH:mm:ss z", null, null);
	
	@Override
	public DownloadGatErrorsResult execute(DownloadGatErrors action, ExecutionContext context)
			throws DispatchException {
		
	    long start = System.currentTimeMillis();
		logger.info("execute() with action: " + action);
		
		String userFile;
		String logFileName;
		StringBuilder sb = new StringBuilder();
		DownloadGatErrorsResult result = new DownloadGatErrorsResult();
		DomainModuleProperties properties = DomainModuleProperties.getInstance();
		
		sb.append("The following is an error report generated by the course creator.");
		sb.append("\n\nUsername:  ").append(action.getUserName());
		sb.append("\nDate: ").append(fdf.format(action.getDate()));
        if(action.getCourseName() != null){
            sb.append("\nCourse: ").append(action.getCourseName());
        }
				
		if(action.getFileName() != null) {
			
			userFile = action.getFileName();
			
			// remove the path from the original file name so it can be used in the log file name
			if(userFile.contains("/")) {
				userFile = userFile.substring(userFile.lastIndexOf("/") + 1);
			} else if(userFile.contains("\\")) {
				userFile = userFile.substring(userFile.lastIndexOf("\\") + 1);	
			}				
			
			sb.append("\nFile: ").append(action.getFileName());
			
		} else {			
			userFile = "error_report";			
		}
		
        sb.append("\n\n");
        
		logFileName = action.getUserName() + "_" + userFile + "_" + TimeUtil.formatCurrentTime();
		final File zipFile = new File(properties.getUploadDirectory() + File.separator + logFileName + ".zip");
		final File logDir  = new File(properties.getUploadDirectory() +  File.separator + logFileName);		
		logDir.mkdir();		
		final File logFile = new File(logDir, logFileName + ".log");			
		
		FileUtil.registerFileToDeleteOnShutdown(logDir);
		zipFile.deleteOnExit();
		
        sb.append("Reason\n").append(action.getReason()).append("\n\n");
        
        if (action.getDetails() != null && !action.getDetails().isEmpty()) {
            
            List<ErrorDetails> errorDetailsList = action.getDetails();
            
            //
            // First the details
            //
            sb.append("Details\n");
            int index = 1;
            for (ErrorDetails errorDetails : errorDetailsList) {
                sb.append(index++).append(". ").append(errorDetails.getDetails()).append("\n\n");
            }
            
            //
            // Second the stack trace
            //
            sb.append("Stack Trace\n");
            index = 1; //reset
            for(ErrorDetails errorDetail : errorDetailsList){
                
                sb.append(index++ +". ");
                
                if(errorDetail.getStacktrace() != null && !errorDetail.getStacktrace().isEmpty()){

                    for (String e : errorDetail.getStacktrace()) {
                        sb.append(e).append("\n");
                    }
                    
                }else{
                    sb.append("No stack trace available.\n");
                }
                
                sb.append("\n\n");
            }

        }else{
            
            sb.append("Details\nNot provided.\n\n");            
            sb.append("Stack Trace\nNo stack trace available.\n");
        }

		try {
			
			logger.info("Attempting to write to file at " + logFile.getPath());
			FileUtils.writeStringToFile(logFile, sb.toString());
			
			List<File> files = new ArrayList<>();
			files.add(logDir);
			
			logger.info("Zipping log file to " + zipFile.getPath());
			ZipUtils.zipFiles(files, zipFile);
			
			FileUtils.deleteDirectory(logDir);
			
			result.setDownloadUrl(ServicesManager.getExportURL(zipFile).toString());
			result.setRelativeFilePath(zipFile.getPath());
			result.setSuccess(true);
			
		} catch (IOException e) {
	        logger.error("Caught exception while attempting to write to file.", e);

			result.setSuccess(false);
			result.setErrorMsg(e.toString());
			
			FileUtils.deleteQuietly(logDir);
			FileUtils.deleteQuietly(zipFile);
		}
		
		Thread deleteLogFileThread = new Thread("Delete Log File Thread"){
			
			@Override
			public void run(){
				try {
					
				    synchronized(this){
    					//wait 30 minutes and then delete the log file if it still exists
    					wait(1800000);
				    }
					
				    try{
				        FileUtils.forceDelete(zipFile);
				    }catch(@SuppressWarnings("unused") FileNotFoundException fnfe){
				        //ignore
				    }catch (IOException e) {
				        logger.warn("An exception occurred while waiting to delete the downloadable zip file.", e);
	                }
				    
				    try{
				        FileUtils.forceDelete(logFile);
                    }catch(@SuppressWarnings("unused") FileNotFoundException fnfe){
                        //ignore
                    }catch (IOException e) {
                        logger.warn("An exception occurred while waiting to delete the log file of a downloadable file.", e);
                    }
				    
				    try{
				        FileUtils.forceDelete(logDir);
                    }catch(@SuppressWarnings("unused") FileNotFoundException fnfe){
                        //ignore
                    }catch (IOException e) {
                        logger.warn("An exception occurred while waiting to delete the log directory of a downloadable file.", e);
                    }
					
				} catch (InterruptedException e) {
					logger.warn("An exception occurred while waiting to cleanup the remnants of a downloadable file.", e);
				}
			}
		};
		
		deleteLogFileThread.start();
		MetricsSenderSingleton.getInstance().endTrackingRpc("util.DownloadGatErrors", start);		
		return result;
	}

	@Override
	public Class<DownloadGatErrors> getActionType() {
		return DownloadGatErrors.class;
	}

	@Override
	public void rollback(DownloadGatErrors action,
			DownloadGatErrorsResult result, ExecutionContext context)
			throws DispatchException {
	}

}
