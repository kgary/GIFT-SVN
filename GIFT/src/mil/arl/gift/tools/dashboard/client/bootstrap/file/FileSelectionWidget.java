/**
 * Copyright Dignitas Technologies, LLC
 * 
 * This file and its contents are governed by one or more distribution and
 * copyright statements as described in the LICENSE.txt file distributed with
 * this work.
 */
package mil.arl.gift.tools.dashboard.client.bootstrap.file;

import org.gwtbootstrap3.client.shared.event.TabShowEvent;
import org.gwtbootstrap3.client.shared.event.TabShowHandler;
import org.gwtbootstrap3.client.ui.Form;
import org.gwtbootstrap3.client.ui.TabListItem;
import org.gwtbootstrap3.client.ui.TabPane;
import org.gwtbootstrap3.client.ui.base.form.AbstractForm.SubmitCompleteEvent;
import org.gwtbootstrap3.client.ui.base.form.AbstractForm.SubmitCompleteHandler;

import mil.arl.gift.common.gwt.client.widgets.file.FileSelectionWidgetUtil;
import mil.arl.gift.common.gwt.client.widgets.file.FileSelectionView.FileSelectionCallback;
import mil.arl.gift.common.io.FileTreeModel;

import com.google.gwt.cell.client.ImageCell;
import com.google.gwt.cell.client.TextCell;
import com.google.gwt.core.client.GWT;
import com.google.gwt.core.client.Scheduler.ScheduledCommand;
import com.google.gwt.uibinder.client.UiBinder;
import com.google.gwt.uibinder.client.UiField;
import com.google.gwt.user.cellview.client.CellTable;
import com.google.gwt.user.cellview.client.Column;
import com.google.gwt.user.client.ui.Composite;
import com.google.gwt.user.client.ui.FileUpload;
import com.google.gwt.user.client.ui.FormPanel;
import com.google.gwt.user.client.ui.HasEnabled;
import com.google.gwt.user.client.ui.HasText;
import com.google.gwt.user.client.ui.HasValue;
import com.google.gwt.user.client.ui.MenuItem;
import com.google.gwt.user.client.ui.ScrollPanel;
import com.google.gwt.user.client.ui.TextBox;
import com.google.gwt.user.client.ui.Widget;
import com.google.gwt.view.client.CellPreviewEvent.Handler;
import com.google.gwt.view.client.HasData;

/**
 * A widget that allows the user to either choose a file to upload to the server or select a file from the server. This widget works a bit 
 * differently than most views in the GAT in that it follows MVP practices for the most part but holds a reference to its own presenter. 
 * Because of this, no prior calls to a presenter class need to be made before using this widget in any interface. 
 * 
 * That said, this widget will not enact any file uploading or file selection logic until submitFileChoice(FileSelectionCallback) is called. 
 * This allows such logic to be delayed until another encompassing presenter determines that such operations should proceed, giving us the 
 * option of canceling a file upload or file selection if a validation check fails. The callback provided will be given the appropriate 
 * file name uploaded or selected once the corresponding operation has completed.
 * 
 * By default, no height is initially declared for the list of server files, meaning the list will be dynamically sized depending on the number 
 * of files in the currently selected directory. In order to set this list to a specific size and enable scrolling, a call must be made to 
 * setFileTableHeight(String height). 
 * 
 * !IMPORTANT!: When uploading a file, this widget MUST be attached to the DOM when submitFileChoice(FileSelectionCallback) is called, 
 * otherwise the upload request will not be sent. The reason for this is that the 'form' element generated by GWT will not be able 
 * to send the appropriate request to the file servlet unless it is attached to the DOM. Any logic that may cause this widget to be 
 * detached from the DOM (e.g. PopupPanel.hide() or DialogBox.hide()) should only be called after the upload request has been processed. 
 * 
 * @author nroberts
 */
public class FileSelectionWidget extends Composite implements FileSelectionView {

	private static FileSelectionWidgetUiBinder uiBinder = GWT
			.create(FileSelectionWidgetUiBinder.class);
	
	/** The directory icon url. */
	private static String DIRECTORY_ICON_URL = "images/folder.png";
	
	/** The file icon url. */
	private static String FILE_ICON_URL = "images/file.png";

	interface FileSelectionWidgetUiBinder extends
			UiBinder<Widget, FileSelectionWidget> {
	}
	
	@UiField
	protected Form form;

	@UiField
	protected FileUpload fileUpload;
	
	/** The up arrow. */
	@UiField
	protected MenuItem upArrow;
	
	/** The up arrow. */
	@UiField
	protected MenuItem directoryName;
	
	/** The file name data grid. */
	@UiField
	protected CellTable<FileTreeModel> fileNameTable;
	
	/** The file name input. */
	@UiField
	protected TextBox fileNameInput;
	
	@UiField
	ScrollPanel fileTableScrollPanel;
	
	@UiField
	TabListItem uploadTab;
	
	@UiField
	TabPane uploadTabPane;
	
	@UiField
	TabListItem myWorkspaceTab;
	
	@UiField
	TabPane myWorkspaceTabPane;
	
	/**
	 * The file upload callback that will be used to handle when the user has made a file selection.
	 */
	private FileSelectionCallback fileUploadCallback = null;
	
	/**
	 * The presenter associated with this file selector. Ordinarily, we wouldn't give the view direct access to its presenter, but in this case, 
	 * we plan to use this widget in a number of places, so we want to keep the process of setting up the widget as simple as possible. Because 
	 * of this, most of the logic used to set up the presenter is handled in the view's constructor, making handling file uploads as simple as 
	 * calling the constructor and then calling submitFileChoice(FileSelectionCallback)
	 */
	private FileSelectionPresenter presenter;
	
	private FileSelectionView.Mode currentMode = FileSelectionView.Mode.UPLOAD;
	
	public ModeChangedCallback modeChangedCallback;
	
	/**
	 * Creates a new file selection widget
	 */
	private FileSelectionWidget(){
		initWidget(uiBinder.createAndBindUi(this));
		
		Column<FileTreeModel, String> fileIconColumn = new Column<FileTreeModel, String>(new ImageCell()){

			@Override
			public String getValue(FileTreeModel object) {

				if(object != null && object.isDirectory()){
					return DIRECTORY_ICON_URL;
					
				} else {
					return FILE_ICON_URL;
				}
			}
			
		};
		fileNameTable.addColumn(fileIconColumn);
		fileNameTable.setColumnWidth(fileIconColumn, "25px");
		
		Column<FileTreeModel, String> fileNameColumn = new Column<FileTreeModel, String>(new TextCell()){

			@Override
			public String getValue(FileTreeModel object) {
				return object.getFileOrDirectoryName();
			}
			
		};
		
		fileNameTable.addColumn(fileNameColumn);
		fileNameTable.setColumnWidth(fileNameColumn, "100%");
		
		fileUpload.setName("uploadFileElement");
		
		form.setAction(GWT.getHostPageBaseURL() + "");
        form.setEncoding(FormPanel.ENCODING_MULTIPART);
        form.setMethod(FormPanel.METHOD_POST);
		
		form.addSubmitCompleteHandler(new SubmitCompleteHandler() {

            @Override
            public void onSubmitComplete(SubmitCompleteEvent event) {
            	
            	FileSelectionWidgetUtil.handleFileUploadResponse(event.getResults(), fileUploadCallback);
            }
        });
		
		presenter = new FileSelectionPresenter(this);
		
		uploadTab.addShowHandler(new TabShowHandler() {
			
			@Override
			public void onShow(TabShowEvent event) {
				
				currentMode = FileSelectionView.Mode.UPLOAD;
				
				if(modeChangedCallback != null){
					modeChangedCallback.onModeChanged(currentMode);
				}
			}
		});
		
		myWorkspaceTab.addShowHandler(new TabShowHandler() {
			
			@Override
			public void onShow(TabShowEvent event) {
				
				currentMode = FileSelectionView.Mode.MY_WORKSPACE;
				
				if(modeChangedCallback != null){
					modeChangedCallback.onModeChanged(currentMode);
				}
			}
		});
	}
	
	/**
	 * Creates a new file selection widget
	 * 
	 * @param uploadServletUrl the URL for the servlet to which this widget should upload files
	 */
	public FileSelectionWidget(String uploadServletUrl){
		
		this();
		
		String hostURL = GWT.getHostPageBaseURL();
		
		if(uploadServletUrl.contains(hostURL)){
			form.setAction(hostURL + uploadServletUrl);
			
		} else {		
			form.setAction(hostURL + uploadServletUrl);
		}
		
		uploadTab.setVisible(true);
		myWorkspaceTab.setVisible(false);
		
		uploadTabPane.setActive(true);
		myWorkspaceTabPane.setActive(false);
		
		uploadTab.showTab(true);
	}
	
	@Override
	public void submitFileChoice(final FileSelectionCallback callback){				
		presenter.submitFileChoice(callback, currentMode);
	}
	
	@Override
	public void uploadChosenFile(final FileSelectionCallback callback){
		
		String[] allowedExtensions = presenter.getAllowedFileExtensions();
		
		String fileName = fileUpload.getFilename();
		
		if(fileName != null && allowedExtensions != null){
			
			boolean hasAllowedExtension = false;
			
			for(String extension : allowedExtensions){
				
				if(fileName.endsWith(extension)){
					hasAllowedExtension = true;
					break;
				}
			}
			
			if(!hasAllowedExtension){
				
				StringBuilder sb = new StringBuilder();
				sb.append("The file selected must have a file name ending in ");
				
				for(int i = 0; i < allowedExtensions.length; i++){
					
					if(i == allowedExtensions.length - 1){
						
						if(allowedExtensions.length == 1){
							sb.append(allowedExtensions[i]);
							
						} else {
							sb.append("or ");
							sb.append(allowedExtensions[i]);
						}
						
					} else if(i == allowedExtensions.length - 1 && allowedExtensions.length == 2){
						sb.append(allowedExtensions[i]);
						sb.append(" ");
						
					} else {
						sb.append(allowedExtensions[i]);
						sb.append(", ");
					}
				}
				
				sb.append(".");
				
				callback.onFailure(sb.toString());
				return;
			}
		}
		
		fileUploadCallback = callback;
		
		form.submit();
	}
	
	@Override
	public void setAllowedFileExtensions(String[] extensions){
		
		StringBuilder acceptValue = new StringBuilder();
		
		for(int i = 0; i < extensions.length; i++){
			
			int lastDotIndex = extensions[i].lastIndexOf(".");
			
			String metaExtension;
			
			/*
			 * Most browsers only recognize the last period and onwards as an actual file extension, so we can't filter for extensions like 
			 * .course.xml or .dkf.xml during uploads. We can, howerver, use the .xml part to have a little bit of filtering, 
			 */
			
			if(lastDotIndex >= 0 && lastDotIndex < extensions[i].length()){
				metaExtension = extensions[i].substring(lastDotIndex, extensions[i].length());
				
			} else {
				metaExtension = extensions[i];
			}
			
			if(i == 0){
				acceptValue.append(metaExtension);
			
			} else {
				acceptValue.append(", ").append(metaExtension);
			}
		}
		
		fileUpload.getElement().setAttribute("accept", acceptValue.toString());
		
		presenter.setAllowedFileExtensions(extensions);
	}
	
	@Override
	public HasData<FileTreeModel> getFileNameDataDisplay() {
		return fileNameTable;
	}

	@Override
	public void setUpArrowCommand(ScheduledCommand command) {
		upArrow.setScheduledCommand(command);
	}

	@Override
	public HasEnabled getUpArrow() {
		return upArrow;
	}

	@Override
	public HasText getDirectoryName() {
		return directoryName;
	}

	@Override
	public HasValue<String> getFileNameInput() {
		return fileNameInput;
	}
	
	/**
	 * Sets the size of the file selection table
	 * 
	 * @param width the width of the file selection table
	 * @param height the height of the file selection table
	 */
	public void setFileTableSize(String width, String height){
		fileTableScrollPanel.setWidth(width);
		fileTableScrollPanel.setHeight(height);
	}
	
	/**
	 * Gets the element used to select a file to upload
	 * 
	 * @return the element used to select a file to upload
	 */
	public FileUpload getFileUpload(){
		return fileUpload;
	}
	
	/**
	 * Resets all fields.
	 */
	public void reset(){
		
		form.reset();
		presenter.refresh();
	}
	
	@Override
	public void resetScroll(){
		fileTableScrollPanel.scrollToTop();
	}
	
	@Override
	public void addCellPreviewHandler(Handler<FileTreeModel> handler){
		
		fileNameTable.addCellPreviewHandler(handler);
	}
	
	@Override
	public boolean isUploadingFile(){
		return currentMode.equals(FileSelectionView.Mode.UPLOAD);
	}

	/* (non-Javadoc)
	 * @see mil.arl.gift.tools.dashboard.client.bootstrap.file.FileSelectionView#setModeChangedCallback(mil.arl.gift.tools.dashboard.client.bootstrap.file.FileSelectionView.ModeChangedCallback)
	 */
	@Override
	public void setModeChangedCallback(ModeChangedCallback callback) {
		this.modeChangedCallback = callback;
	}
}
