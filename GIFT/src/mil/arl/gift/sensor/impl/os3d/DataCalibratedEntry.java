/**
 * Copyright Dignitas Technologies, LLC
 * 
 * This file and its contents are governed by one or more distribution and
 * copyright statements as described in the LICENSE.txt file distributed with
 * this work.
 */
package mil.arl.gift.sensor.impl.os3d;

import java.util.Arrays;
import java.util.List;

import com.sun.jna.Structure;
import com.sun.jna.Union;

/**
 * This file was autogenerated by <a
 * href="http://jnaerator.googlecode.com/">JNAerator</a>,<br>
 * a tool written by <a href="http://ochafik.com/">Olivier Chafik</a> that <a
 * href="http://code.google.com/p/jnaerator/wiki/CreditsAndLicense">uses a few
 * opensource projects.</a>.<br>
 * For help, please visit <a
 * href="http://nativelibs4java.googlecode.com/">NativeLibs4Java</a> , <a
 * href="http://rococoa.dev.java.net/">Rococoa</a>, or <a
 * href="http://jna.dev.java.net/">JNA</a>.
 */
@SuppressWarnings("all")
public class DataCalibratedEntry extends Union {

    // / C type : field1_struct
    public field1_struct field1;
    // / C type : double[10]
    public double[] dCalibrated = new double[10];

    // / <i>native declaration : line 36</i>
    // / <i>native declaration : line 36</i>
    public static class field1_struct extends Structure {
        // / C type : double[3]
        public double[] dCalibratedAcc = new double[3];
        // / C type : double[3]
        public double[] dCalibratedGyr = new double[3];
        // / C type : double[3]
        public double[] dCalibratedMag = new double[3];
        public double dCalibratedReserved;

        public field1_struct() {
            super();
        }

        protected List<String> getFieldOrder() {
            return Arrays.asList("dCalibratedAcc", "dCalibratedGyr",
                    "dCalibratedMag", "dCalibratedReserved");
        }

        /**
         * @param dCalibratedAcc C type : double[3]<br>
         * @param dCalibratedGyr C type : double[3]<br>
         * @param dCalibratedMag C type : double[3]
         * @param dCalibratedReserved unknown
         */
        public field1_struct(double dCalibratedAcc[], double dCalibratedGyr[],
                double dCalibratedMag[], double dCalibratedReserved) {
            super();
            if (dCalibratedAcc.length != this.dCalibratedAcc.length)
                throw new IllegalArgumentException("Wrong array size !");
            this.dCalibratedAcc = dCalibratedAcc;
            if (dCalibratedGyr.length != this.dCalibratedGyr.length)
                throw new IllegalArgumentException("Wrong array size !");
            this.dCalibratedGyr = dCalibratedGyr;
            if (dCalibratedMag.length != this.dCalibratedMag.length)
                throw new IllegalArgumentException("Wrong array size !");
            this.dCalibratedMag = dCalibratedMag;
            this.dCalibratedReserved = dCalibratedReserved;
        }

        public static class ByReference extends field1_struct implements
                Structure.ByReference {

        };

        public static class ByValue extends field1_struct implements
                Structure.ByValue {

        };
    };

    public DataCalibratedEntry() {
        super();
    }

    // / @param dCalibrated C type : double[10]
    public DataCalibratedEntry(double dCalibrated[]) {
        super();
        if (dCalibrated.length != this.dCalibrated.length)
            throw new IllegalArgumentException("Wrong array size !");
        this.dCalibrated = dCalibrated;
        setType(double[].class);
    }

    // / @param field1 C type : field1_struct
    public DataCalibratedEntry(field1_struct field1) {
        super();
        this.field1 = field1;
        setType(field1_struct.class);
    }

    public static class ByReference extends DataCalibratedEntry implements
            Structure.ByReference {

    };

    public static class ByValue extends DataCalibratedEntry implements
            Structure.ByValue {

    };
}
